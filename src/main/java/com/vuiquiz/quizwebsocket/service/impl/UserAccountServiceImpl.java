package com.vuiquiz.quizwebsocket.service.impl;

import com.vuiquiz.quizwebsocket.exception.ResourceNotFoundException;
import com.vuiquiz.quizwebsocket.model.UserAccount;
import com.vuiquiz.quizwebsocket.repository.UserAccountRepository;
import com.vuiquiz.quizwebsocket.service.UserAccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.crypto.password.PasswordEncoder; // Import PasswordEncoder
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;
import java.util.UUID;

@Service
public class UserAccountServiceImpl implements UserAccountService {

    private final UserAccountRepository userAccountRepository;
    private final PasswordEncoder passwordEncoder; // Inject PasswordEncoder

    @Autowired
    public UserAccountServiceImpl(UserAccountRepository userAccountRepository, PasswordEncoder passwordEncoder) { // Autowire PasswordEncoder
        this.userAccountRepository = userAccountRepository;
        this.passwordEncoder = passwordEncoder; // Assign it
    }

    @Override
    @Transactional
    public UserAccount createUser(UserAccount userAccount) {
        if (userAccountRepository.existsByUsername(userAccount.getUsername())) {
            throw new IllegalArgumentException("Username already exists: " + userAccount.getUsername());
        }
        if (userAccount.getEmail() != null && userAccountRepository.existsByEmail(userAccount.getEmail())) {
            throw new IllegalArgumentException("Email already exists: " + userAccount.getEmail());
        }
        // Encode password before saving
        userAccount.setAccountPassword(passwordEncoder.encode(userAccount.getAccountPassword()));
        userAccount.setUserId(null); // Ensure ID is generated by DB
        return userAccountRepository.save(userAccount);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<UserAccount> getUserById(UUID userId) {
        return userAccountRepository.findById(userId);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<UserAccount> getUserByUsername(String username) {
        return userAccountRepository.findByUsername(username);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<UserAccount> getUserByEmail(String email) {
        return userAccountRepository.findByEmail(email);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<UserAccount> getAllUsers(Pageable pageable) {
        return userAccountRepository.findAll(pageable);
    }

    @Override
    @Transactional
    public UserAccount updateUser(UUID userId, UserAccount userDetails) {
        UserAccount existingUser = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId));

        if (userDetails.getEmail() != null && !userDetails.getEmail().equals(existingUser.getEmail())) {
            if (userAccountRepository.existsByEmail(userDetails.getEmail())) {
                throw new IllegalArgumentException("Email already exists: " + userDetails.getEmail());
            }
            existingUser.setEmail(userDetails.getEmail());
        }
        // existingUser.setRole(userDetails.getRole()); // Prefer specific methods like updateUserRole
        existingUser.setStorageUsed(userDetails.getStorageUsed()); // Example field
        // Password updates should go through a dedicated method like updateUserPassword
        return userAccountRepository.save(existingUser);
    }

    @Override
    @Transactional
    public void deleteUser(UUID userId) {
        UserAccount user = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId));
        userAccountRepository.delete(user);
    }

    @Override
    @Transactional
    public UserAccount updateUserRole(UUID userId, String newRole) {
        UserAccount user = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId));
        user.setRole(newRole); // Add validation for role if needed
        return userAccountRepository.save(user);
    }

    @Override
    @Transactional
    public UserAccount updateUserPassword(UUID userId, String newPassword) {
        UserAccount user = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId));
        // Encode the new password
        user.setAccountPassword(passwordEncoder.encode(newPassword));
        return userAccountRepository.save(user);
    }

    @Override
    @Transactional(readOnly = true)
    public boolean canUserUpload(UUID userId, long fileSize) {
        UserAccount user = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId));

        if (fileSize < 0) {
            throw new IllegalArgumentException("File size cannot be negative.");
        }
        // storageLimit might be null if not set on older accounts or if schema doesn't enforce NOT NULL yet.
        // Default to a very high limit or handle as per business rules if null.
        // For this implementation, we assume storageLimit is NOT NULL and has a default.
        return (user.getStorageUsed() + fileSize) <= user.getStorageLimit();
    }

    @Override
    @Transactional
    public UserAccount updateUserStorageUsed(UUID userId, long fileSizeDelta) {
        UserAccount user = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId));

        long newStorageUsed = user.getStorageUsed() + fileSizeDelta;
        if (newStorageUsed < 0) {
            // This case should ideally not happen if logic is correct (e.g., deleting a non-existent file's size)
            // Log a warning, or throw an exception, or cap at 0.
            // For robustness, let's cap at 0 and log.
            newStorageUsed = 0;
            // Consider logging this anomaly:
            // log.warn("Attempted to set negative storage for user {}. Capped at 0. Delta was: {}", userId, fileSizeDelta);
        }

        // Optional: Re-check against limit if adding storage, though `canUserUpload` should prevent exceeding.
        // if (fileSizeDelta > 0 && newStorageUsed > user.getStorageLimit()) {
        //     throw new StorageQuotaExceededException("Updating storage would exceed user's limit.");
        // }

        user.setStorageUsed(newStorageUsed);
        return userAccountRepository.save(user);
    }
}