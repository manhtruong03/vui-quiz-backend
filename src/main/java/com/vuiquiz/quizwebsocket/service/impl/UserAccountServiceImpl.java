package com.vuiquiz.quizwebsocket.service.impl;

import com.vuiquiz.quizwebsocket.dto.UserAccountAdminViewDTO;
import com.vuiquiz.quizwebsocket.dto.UserAccountCreationRequestDTO;
import com.vuiquiz.quizwebsocket.dto.UserAccountUpdateRequestDTO;
import com.vuiquiz.quizwebsocket.exception.ResourceNotFoundException;
import com.vuiquiz.quizwebsocket.model.UserAccount;
import com.vuiquiz.quizwebsocket.repository.UserAccountRepository;
import com.vuiquiz.quizwebsocket.service.UserAccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.crypto.password.PasswordEncoder; // Import PasswordEncoder
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.Optional;
import java.util.UUID;

@Service
public class UserAccountServiceImpl implements UserAccountService {

    private final UserAccountRepository userAccountRepository;
    private final PasswordEncoder passwordEncoder; // Inject PasswordEncoder

    @Autowired
    public UserAccountServiceImpl(UserAccountRepository userAccountRepository, PasswordEncoder passwordEncoder) { // Autowire PasswordEncoder
        this.userAccountRepository = userAccountRepository;
        this.passwordEncoder = passwordEncoder; // Assign it
    }

    @Override
    @Transactional
    public UserAccount createUser(UserAccount userAccount) {
        if (userAccountRepository.existsByUsername(userAccount.getUsername())) {
            throw new IllegalArgumentException("Username already exists: " + userAccount.getUsername());
        }
        if (userAccount.getEmail() != null && userAccountRepository.existsByEmail(userAccount.getEmail())) {
            throw new IllegalArgumentException("Email already exists: " + userAccount.getEmail());
        }
        // Encode password before saving
        userAccount.setAccountPassword(passwordEncoder.encode(userAccount.getAccountPassword()));
        userAccount.setUserId(null); // Ensure ID is generated by DB
        return userAccountRepository.save(userAccount);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<UserAccount> getUserById(UUID userId) {
        return userAccountRepository.findById(userId);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<UserAccount> getUserByUsername(String username) {
        return userAccountRepository.findByUsername(username);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<UserAccount> getUserByEmail(String email) {
        return userAccountRepository.findByEmail(email);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<UserAccount> getAllUsers(Pageable pageable) {
        return userAccountRepository.findAll(pageable);
    }

    @Override
    @Transactional
    public UserAccount updateUser(UUID userId, UserAccount userDetails) {
        UserAccount existingUser = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId));

        if (userDetails.getEmail() != null && !userDetails.getEmail().equals(existingUser.getEmail())) {
            if (userAccountRepository.existsByEmail(userDetails.getEmail())) {
                throw new IllegalArgumentException("Email already exists: " + userDetails.getEmail());
            }
            existingUser.setEmail(userDetails.getEmail());
        }
        // existingUser.setRole(userDetails.getRole()); // Prefer specific methods like updateUserRole
        existingUser.setStorageUsed(userDetails.getStorageUsed()); // Example field
        // Password updates should go through a dedicated method like updateUserPassword
        return userAccountRepository.save(existingUser);
    }

    @Override
    @Transactional
    public void deleteUser(UUID userId) {
        UserAccount user = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId));
        userAccountRepository.delete(user);
    }

    @Override
    @Transactional
    public UserAccount updateUserRole(UUID userId, String newRole) {
        UserAccount user = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId));
        user.setRole(newRole); // Add validation for role if needed
        return userAccountRepository.save(user);
    }

    @Override
    @Transactional
    public UserAccount updateUserPassword(UUID userId, String newPassword) {
        UserAccount user = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId));
        // Encode the new password
        user.setAccountPassword(passwordEncoder.encode(newPassword));
        return userAccountRepository.save(user);
    }

    @Override
    @Transactional(readOnly = true)
    public boolean canUserUpload(UUID userId, long fileSize) {
        UserAccount user = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId));

        if (fileSize < 0) {
            throw new IllegalArgumentException("File size cannot be negative.");
        }
        // storageLimit might be null if not set on older accounts or if schema doesn't enforce NOT NULL yet.
        // Default to a very high limit or handle as per business rules if null.
        // For this implementation, we assume storageLimit is NOT NULL and has a default.
        return (user.getStorageUsed() + fileSize) <= user.getStorageLimit();
    }

    @Override
    @Transactional
    public UserAccount updateUserStorageUsed(UUID userId, long fileSizeDelta) {
        UserAccount user = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId));

        long newStorageUsed = user.getStorageUsed() + fileSizeDelta;
        if (newStorageUsed < 0) {
            // This case should ideally not happen if logic is correct (e.g., deleting a non-existent file's size)
            // Log a warning, or throw an exception, or cap at 0.
            // For robustness, let's cap at 0 and log.
            newStorageUsed = 0;
            // Consider logging this anomaly:
            // log.warn("Attempted to set negative storage for user {}. Capped at 0. Delta was: {}", userId, fileSizeDelta);
        }

        // Optional: Re-check against limit if adding storage, though `canUserUpload` should prevent exceeding.
        // if (fileSizeDelta > 0 && newStorageUsed > user.getStorageLimit()) {
        //     throw new StorageQuotaExceededException("Updating storage would exceed user's limit.");
        // }

        user.setStorageUsed(newStorageUsed);
        return userAccountRepository.save(user);
    }

    private static UserAccountAdminViewDTO toUserAccountAdminViewDTO(UserAccount userAccount) {
        if (userAccount == null) {
            return null;
        }
        return UserAccountAdminViewDTO.builder()
                .userId(userAccount.getUserId())
                .username(userAccount.getUsername())
                .email(userAccount.getEmail())
                .role(userAccount.getRole())
                .storageUsed(userAccount.getStorageUsed())
                .storageLimit(userAccount.getStorageLimit())
                .createdAt(userAccount.getCreatedAt())
                .updatedAt(userAccount.getUpdatedAt())
                .deletedAt(userAccount.getDeletedAt())
                .build();
    }

    @Override
    @Transactional
    public UserAccountAdminViewDTO createUserByAdmin(UserAccountCreationRequestDTO creationRequest) {
        if (userAccountRepository.existsByUsername(creationRequest.getUsername())) {
            throw new IllegalArgumentException("Error: Username is already taken! - " + creationRequest.getUsername());
        }

        if (StringUtils.hasText(creationRequest.getEmail()) && userAccountRepository.existsByEmail(creationRequest.getEmail())) {
            throw new IllegalArgumentException("Error: Email is already in use! - " + creationRequest.getEmail());
        }

        // Basic role validation (can be expanded to check against a predefined list)
        if (!StringUtils.hasText(creationRequest.getRole())) {
            throw new IllegalArgumentException("Error: Role cannot be empty.");
        }
        // Consider uppercasing the role or having a predefined enum for roles
        String roleToSet = creationRequest.getRole().toUpperCase(); // Example: Store roles in uppercase

        UserAccount user = UserAccount.builder()
                .username(creationRequest.getUsername())
                .accountPassword(passwordEncoder.encode(creationRequest.getPassword()))
                .role(roleToSet)
                // email is set below to handle null/blank
                // storageUsed and storageLimit will use @Builder.Default from UserAccount entity
                // createdAt and updatedAt will be set by @PrePersist
                .build();

        if (StringUtils.hasText(creationRequest.getEmail())) {
            user.setEmail(creationRequest.getEmail());
        }
        // Ensure userId is null so it's generated by the database
        user.setUserId(null);


        UserAccount savedUser = userAccountRepository.save(user);
        return toUserAccountAdminViewDTO(savedUser);
    }

    @Override
    @Transactional
    public UserAccountAdminViewDTO updateUserByAdmin(UUID userId, UserAccountUpdateRequestDTO updateRequest) {
        UserAccount existingUser = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId));

        boolean updated = false;

        // Update Username
        if (StringUtils.hasText(updateRequest.getUsername()) && !updateRequest.getUsername().equals(existingUser.getUsername())) {
            if (userAccountRepository.existsByUsername(updateRequest.getUsername())) {
                throw new IllegalArgumentException("Error: New username '" + updateRequest.getUsername() + "' is already taken!");
            }
            existingUser.setUsername(updateRequest.getUsername());
            updated = true;
        }

        // Update Email
        // This logic allows setting email to null (if DTO email is null)
        // or updating it if DTO email is a non-blank string and different from current.
        if (updateRequest.getEmail() == null) { // Explicit request to clear email
            if (existingUser.getEmail() != null) {
                existingUser.setEmail(null);
                updated = true;
            }
        } else if (StringUtils.hasText(updateRequest.getEmail())) { // DTO email is not blank
            if (!updateRequest.getEmail().equals(existingUser.getEmail())) { // And different from current email
                if (userAccountRepository.existsByEmail(updateRequest.getEmail())) {
                    throw new IllegalArgumentException("Error: New email '" + updateRequest.getEmail() + "' is already in use!");
                }
                existingUser.setEmail(updateRequest.getEmail());
                updated = true;
            }
        }
        // If DTO email is present but blank (e.g., ""), it means no change to email or clear email if it was previously set.
        // The current logic handles this: if DTO.email is "" (blank but not null), StringUtils.hasText(updateRequest.getEmail()) is false,
        // so it falls through, and no change occurs unless existingUser.getEmail() was not null and DTO.getEmail() was null.
        // To explicitly clear email with blank string:
        else if (updateRequest.getEmail() != null && updateRequest.getEmail().isEmpty() && existingUser.getEmail() != null) { // DTO email is ""
            existingUser.setEmail(null);
            updated = true;
        }


        // Update Role
        if (StringUtils.hasText(updateRequest.getRole()) && !updateRequest.getRole().equalsIgnoreCase(existingUser.getRole())) {
            // Future: Add validation against a predefined list of roles if needed
            existingUser.setRole(updateRequest.getRole().toUpperCase());
            updated = true;
        }

        // Update Storage Limit
        if (updateRequest.getStorageLimit() != null) {
            if (updateRequest.getStorageLimit() < 0) {
                throw new IllegalArgumentException("Error: Storage limit cannot be negative.");
            }
            // Optional: Add business rule:
            // if (updateRequest.getStorageLimit() < existingUser.getStorageUsed()) {
            //     throw new IllegalArgumentException("Error: Storage limit cannot be less than current storage used by the user.");
            // }
            if (!updateRequest.getStorageLimit().equals(existingUser.getStorageLimit())) {
                existingUser.setStorageLimit(updateRequest.getStorageLimit());
                updated = true;
            }
        }

        if (updated) {
            // The @PreUpdate annotation on UserAccount entity will automatically update 'updatedAt'
            UserAccount savedUser = userAccountRepository.save(existingUser);
            return toUserAccountAdminViewDTO(savedUser);
        } else {
            // If nothing was actually changed, still return the current state of the user
            return toUserAccountAdminViewDTO(existingUser);
        }
    }

    @Override
    @Transactional
    public void adminSetUserPassword(UUID userId, String newPassword) {
        // This directly calls the existing updateUserPassword method,
        // which handles fetching the user, encoding the new password, and saving the entity.
        this.updateUserPassword(userId, newPassword);
        // Note: updateUserPassword already throws ResourceNotFoundException if user not found
        // and handles password encoding.
    }

    @Override
    @Transactional
    public void deleteUserByAdmin(UUID userId) {
        // Check if the user exists and is not already soft-deleted (due to @Where clause)
        UserAccount userAccount = userAccountRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("UserAccount", "id", userId + " (User not found or already deleted)"));

        // JPA's deleteById will trigger the @SQLDelete logic due to entity annotations
        userAccountRepository.deleteById(userAccount.getUserId());
        // Alternatively, userAccountRepository.delete(userAccount); also works.
    }
}