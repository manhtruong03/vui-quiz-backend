package com.vuiquiz.quizwebsocket.service.impl;

import com.vuiquiz.quizwebsocket.dto.ImageStorageAdminViewDTO;
import com.vuiquiz.quizwebsocket.dto.ImageStorageUpdateDTO;
import com.vuiquiz.quizwebsocket.exception.FileStorageException;
import com.vuiquiz.quizwebsocket.exception.MyFileNotFoundException;
import com.vuiquiz.quizwebsocket.exception.ResourceNotFoundException;
import com.vuiquiz.quizwebsocket.model.ImageStorage;
import com.vuiquiz.quizwebsocket.model.UserAccount;
import com.vuiquiz.quizwebsocket.repository.ImageStorageRepository;
import com.vuiquiz.quizwebsocket.repository.UserAccountRepository;
import com.vuiquiz.quizwebsocket.service.FileStorageService;
import com.vuiquiz.quizwebsocket.service.ImageStorageService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder; // For URL building

import java.util.List;
import java.util.Objects; // For Objects.requireNonNull
import java.util.Optional;
import java.util.UUID;

@Service
@Slf4j
public class ImageStorageServiceImpl implements ImageStorageService {

    private final ImageStorageRepository imageStorageRepository;
    private final FileStorageService fileStorageService;
    private final UserAccountRepository userAccountRepository;

    @Autowired
    public ImageStorageServiceImpl(ImageStorageRepository imageStorageRepository, FileStorageService fileStorageService, UserAccountRepository userAccountRepository) {
        this.imageStorageRepository = imageStorageRepository;
        this.fileStorageService = fileStorageService;
        this.userAccountRepository = userAccountRepository;
    }

    @Override
    @Transactional
    public ImageStorage createImageRecord(MultipartFile originalFile, String storedFilename, UUID creatorId) {
        if (originalFile == null || originalFile.isEmpty()) {
            throw new IllegalArgumentException("Original file cannot be null or empty.");
        }
        if (!StringUtils.hasText(storedFilename)) {
            throw new IllegalArgumentException("Stored filename cannot be empty.");
        }
        // creatorId can be null if uploads are allowed anonymously, but for quizzes, it should be present.
        // We'll enforce creatorId presence in the calling service (QuizService).

        ImageStorage newImage = ImageStorage.builder()
                .creatorId(creatorId)
                .fileName(StringUtils.cleanPath(Objects.requireNonNull(originalFile.getOriginalFilename())))
                .filePath(storedFilename) // This is the unique name like UUID.ext
                .contentType(originalFile.getContentType())
                .fileSize(originalFile.getSize())
                // createdAt and updatedAt are set by @PrePersist
                .build();
        return imageStorageRepository.save(newImage);
    }


    @Override
    @Transactional // Kept from existing, good for consistency
    public ImageStorage createImageStorage(ImageStorage imageStorage) {
        // This is the old generic method. We prefer createImageRecord for new uploads.
        // It can still be used internally if an ImageStorage object is pre-built.
        imageStorage.setImageId(null); // Ensure ID is generated by DB
        return imageStorageRepository.save(imageStorage);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<ImageStorage> getImageStorageById(UUID imageId) {
        return imageStorageRepository.findById(imageId);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<ImageStorage> getImageByFilePath(String storedFilePath) {
        // This should query by the unique 'filePath' (e.g., UUID.ext)
        return imageStorageRepository.findByFilePath(storedFilePath);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ImageStorage> getImagesByCreatorId(UUID creatorId) {
        return imageStorageRepository.findByCreatorId(creatorId);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<ImageStorage> getAllImageStorages(Pageable pageable) {
        return imageStorageRepository.findAll(pageable);
    }

    @Override
    @Transactional
    public ImageStorage updateImageStorage(UUID imageId, ImageStorage imageDetails) {
        ImageStorage existingImage = imageStorageRepository.findById(imageId)
                .orElseThrow(() -> new ResourceNotFoundException("ImageStorage", "id", imageId));

        // Update allowed fields
        if (StringUtils.hasText(imageDetails.getFileName())) { // Original filename
            existingImage.setFileName(imageDetails.getFileName());
        }
        // filePath (stored unique name) should typically not be updated directly unless it's a file move operation.
        // existingImage.setFilePath(imageDetails.getFilePath());
        if (imageDetails.getFileSize() != null) {
            existingImage.setFileSize(imageDetails.getFileSize());
        }
        if (StringUtils.hasText(imageDetails.getContentType())) {
            existingImage.setContentType(imageDetails.getContentType());
        }
        // creatorId might be updatable in some scenarios, but usually not.

        // updatedAt is handled by @PreUpdate
        return imageStorageRepository.save(existingImage);
    }

    @Override
    @Transactional
    public void deleteImageStorage(UUID imageId) {
        // In later stages, this should also delete the file from FileStorageService
        ImageStorage image = imageStorageRepository.findById(imageId)
                .orElseThrow(() -> new ResourceNotFoundException("ImageStorage", "id", imageId));
        imageStorageRepository.delete(image); // Soft delete if @SQLDelete is used, otherwise hard delete
    }

    @Override
    @Transactional // This transaction should ideally be part of a larger one in QuizService
    public long deleteImageStorageAndFile(UUID imageId) {
        ImageStorage imageRecord = imageStorageRepository.findById(imageId)
                .orElseThrow(() -> new ResourceNotFoundException("ImageStorage record not found with id: " + imageId));

        String storedFilePath = imageRecord.getFilePath();
        long fileSize = imageRecord.getFileSize() != null ? imageRecord.getFileSize() : 0L;

        try {
            if (StringUtils.hasText(storedFilePath)) {
                fileStorageService.deleteFile(storedFilePath);
                log.info("Successfully deleted physical file: {}", storedFilePath);
            } else {
                log.warn("ImageStorage record {} has no filePath, cannot delete physical file.", imageId);
            }
        } catch (MyFileNotFoundException e) {
            // File was already gone from disk, but DB record exists. Log it.
            // This is acceptable for deletion, as the goal is to remove the DB record.
            log.warn("Physical file {} for ImageStorage record {} was not found during deletion: {}", storedFilePath, imageId, e.getMessage());
        } catch (FileStorageException e) {
            // Failed to delete the physical file for some other reason.
            // This is more problematic. Depending on policy, you might:
            // 1. Re-throw the exception and prevent DB record deletion (safest for consistency).
            // 2. Log the error and proceed with DB record deletion (might leave orphaned files if transaction rolls back later).
            // For now, let's re-throw to ensure the operation is fully successful or fully fails.
            log.error("Failed to delete physical file {} for ImageStorage record {}: {}", storedFilePath, imageId, e.getMessage());
            throw e; // Re-throw to potentially roll back the transaction if this is part of a larger one
        }

        imageStorageRepository.delete(imageRecord); // Perform soft or hard delete based on entity config
        log.info("Successfully deleted ImageStorage record: {}", imageId);
        return fileSize;
    }

    @Override
    @Transactional
    public ImageStorage findOrCreateByFilePath(String filePath, UUID creatorId) {
        // This method seems to assume filePath is a public URL or an external path.
        // For our internal flow, 'filePath' argument here would ideally be the unique stored name.
        // If it's an external URL, it needs to download it first, which is beyond this stage.
        // Let's assume for now 'filePath' is the unique stored name.
        // If so, it simplifies to:
        // return imageStorageRepository.findByFilePath(filePath).orElseGet(() -> {
        //      // This part is tricky if we only have the stored path.
        //      // We'd need original filename, content type, size to create a new record.
        //      // This method might be better suited for scenarios where you're trying to reference an existing image by its URL.
        //      // For now, let's keep the existing implementation and refine if its use case becomes clearer.
        // });

        // Your existing implementation:
        if (filePath == null || filePath.trim().isEmpty()) {
            return null; // Or throw IllegalArgumentException
        }
        Optional<ImageStorage> existingImage = imageStorageRepository.findByFilePath(filePath); // Assumes filePath is the unique stored name
        if (existingImage.isPresent()) {
            return existingImage.get();
        } else {
            // This 'else' block is problematic if filePath is just a URL, as we don't have the MultipartFile.
            // For this stage, we will primarily use `createImageRecord`.
            // The existing `findOrCreateByFilePath` logic might be useful if you receive full image URLs
            // in DTOs from external sources and want to internalize them.
            // If `filePath` here IS the unique stored filename that somehow wasn't in DB:
            // This indicates an inconsistency or a different use case.
            // For now, let's keep it but note that `createImageRecord` is for new uploads.

            String originalFileNameFromFilePath = filePath.substring(filePath.lastIndexOf('/') + 1);
            String extension = StringUtils.getFilenameExtension(originalFileNameFromFilePath);
            String contentType = "image/" + (extension != null ? extension : "jpeg");

            ImageStorage newImage = ImageStorage.builder()
                    .filePath(filePath) // This is the UNIQUE stored path
                    .creatorId(creatorId)
                    .fileName(originalFileNameFromFilePath) // Best guess for original name
                    .contentType(contentType)
                    .fileSize(0L) // Placeholder, actual size not known from just URL
                    .build();
            return imageStorageRepository.save(newImage);
        }
    }

    @Override
    public String getPublicUrl(ImageStorage imageStorage) {
        if (imageStorage == null || !StringUtils.hasText(imageStorage.getFilePath())) {
            return null;
        }
        return getPublicUrl(imageStorage.getFilePath());
    }

    @Override
    public String getPublicUrl(String storedFilename) {
        if (!StringUtils.hasText(storedFilename)) {
            return null;
        }

        // Convert to lowercase for a case-insensitive check for "http://" or "https://"
        String lowerCaseStoredFilename = storedFilename.toLowerCase();

        // Check if the storedFilename is already an absolute URL
        if (lowerCaseStoredFilename.startsWith("http://") || lowerCaseStoredFilename.startsWith("https://")) {
            return storedFilename; // It's already a full URL, return it as is.
        }

        // Otherwise, assume it's a local file and construct the URL
        // Ensure no leading slashes if storedFilename is just the name intended for local path construction
        String cleanStoredFilename = storedFilename.startsWith("/") ? storedFilename.substring(1) : storedFilename;

        return ServletUriComponentsBuilder.fromCurrentContextPath()
                .path("/files/images/") // Matches FileController endpoint
                .path(cleanStoredFilename) // cleanStoredFilename should be just the filename like "uuid.jpg"
                .toUriString();
    }

    @Override
    public String getPublicUrl(UUID imageId) { // ADD THIS IMPLEMENTATION
        if (imageId == null) {
            return null;
        }
        return imageStorageRepository.findById(imageId)
                .map(this::getPublicUrl) // Calls the existing getPublicUrl(ImageStorage imageStorage)
                .orElse(null);
    }

    // Helper method to map ImageStorage entity to ImageStorageAdminViewDTO
    private ImageStorageAdminViewDTO mapEntityToAdminViewDTO(ImageStorage entity) {
        if (entity == null) {
            return null;
        }

        String creatorUsername = null;
        if (entity.getCreatorId() != null) {
            creatorUsername = userAccountRepository.findById(entity.getCreatorId())
                    .map(UserAccount::getUsername)
                    .orElse("N/A"); // Or null, depending on how you want to handle missing creators
        }

        return ImageStorageAdminViewDTO.builder()
                .imageId(entity.getImageId())
                .originalFileName(entity.getFileName())
                .storedFileName(entity.getFilePath())
                .publicUrl(getPublicUrl(entity.getFilePath())) // Use existing method
                .contentType(entity.getContentType())
                .fileSize(entity.getFileSize())
                .creatorId(entity.getCreatorId())
                .creatorUsername(creatorUsername)
                .createdAt(entity.getCreatedAt())
                .updatedAt(entity.getUpdatedAt())
                .build();
    }

    @Override
    @Transactional(readOnly = true)
    public Page<ImageStorageAdminViewDTO> getAllImageRecords(Pageable pageable) {
        Page<ImageStorage> imagePage = imageStorageRepository.findAll(pageable);
        return imagePage.map(this::mapEntityToAdminViewDTO);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<ImageStorageAdminViewDTO> getImageRecordById(UUID imageId) {
        return imageStorageRepository.findById(imageId)
                .map(this::mapEntityToAdminViewDTO);
    }

    @Override
    @Transactional // Ensure this operation is transactional
    public ImageStorageAdminViewDTO createImageRecordAndGetDTO(MultipartFile originalFile, String storedFilename, UUID creatorId) {
        // createImageRecord is the existing method that saves the ImageStorage entity
        ImageStorage imageRecord = this.createImageRecord(originalFile, storedFilename, creatorId);
        // mapEntityToAdminViewDTO is the helper method created in Phase 1
        return this.mapEntityToAdminViewDTO(imageRecord);
    }

    @Override
    @Transactional // Ensure the operation is transactional
    public ImageStorageAdminViewDTO updateImageMetadata(UUID imageId, ImageStorageUpdateDTO updateDTO) {
        ImageStorage existingImage = imageStorageRepository.findById(imageId)
                .orElseThrow(() -> new ResourceNotFoundException("ImageStorage", "id", imageId));

        boolean updated = false;

        // Update originalFileName if provided and not blank
        if (updateDTO.getOriginalFileName() != null) {
            String newOriginalFileName = updateDTO.getOriginalFileName().trim();
            if (!newOriginalFileName.isEmpty() && !newOriginalFileName.equals(existingImage.getFileName())) {
                if (newOriginalFileName.length() > 255) { // Basic validation, can be enhanced
                    throw new IllegalArgumentException("Original filename cannot exceed 255 characters.");
                }
                existingImage.setFileName(newOriginalFileName);
                updated = true;
                log.info("Updating originalFileName for imageId {} to '{}'", imageId, newOriginalFileName);
            } else if (newOriginalFileName.isEmpty() && updateDTO.getOriginalFileName() != null) {
                // Explicitly trying to set to empty string - decide if this is allowed or should be an error/no-op
                // For now, let's treat it as a no-op if the intent was to clear via empty string but originalFileName was already set.
                // If you want to allow clearing to null, the DTO field would need to explicitly allow null and DB schema too.
                log.info("Attempt to set originalFileName to empty for imageId {}, originalFileName in DTO was present but empty. No change made.", imageId);

            }
        }
        // Add logic for other updatable fields here in the future
        // e.g., if (updateDTO.getAltText() != null) { ... }

        if (updated) {
            // The @PreUpdate annotation on ImageStorage entity will automatically update 'updatedAt'
            ImageStorage savedImage = imageStorageRepository.save(existingImage);
            log.info("Image metadata updated for imageId: {}", imageId);
            return mapEntityToAdminViewDTO(savedImage); // Reuse helper from Phase 1
        } else {
            log.info("No metadata changes applied for imageId: {}. Returning current state.", imageId);
            return mapEntityToAdminViewDTO(existingImage); // Return current state if no changes were made
        }
    }
}