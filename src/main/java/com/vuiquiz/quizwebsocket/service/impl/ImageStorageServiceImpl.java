package com.vuiquiz.quizwebsocket.service.impl;

import com.vuiquiz.quizwebsocket.exception.FileStorageException;
import com.vuiquiz.quizwebsocket.exception.MyFileNotFoundException;
import com.vuiquiz.quizwebsocket.exception.ResourceNotFoundException;
import com.vuiquiz.quizwebsocket.model.ImageStorage;
import com.vuiquiz.quizwebsocket.repository.ImageStorageRepository;
import com.vuiquiz.quizwebsocket.service.FileStorageService;
import com.vuiquiz.quizwebsocket.service.ImageStorageService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder; // For URL building

import java.util.List;
import java.util.Objects; // For Objects.requireNonNull
import java.util.Optional;
import java.util.UUID;

@Service
@Slf4j
public class ImageStorageServiceImpl implements ImageStorageService {

    private final ImageStorageRepository imageStorageRepository;
    private final FileStorageService fileStorageService;

    @Autowired
    public ImageStorageServiceImpl(ImageStorageRepository imageStorageRepository, FileStorageService fileStorageService) {
        this.imageStorageRepository = imageStorageRepository;
        this.fileStorageService = fileStorageService;
    }

    @Override
    @Transactional
    public ImageStorage createImageRecord(MultipartFile originalFile, String storedFilename, UUID creatorId) {
        if (originalFile == null || originalFile.isEmpty()) {
            throw new IllegalArgumentException("Original file cannot be null or empty.");
        }
        if (!StringUtils.hasText(storedFilename)) {
            throw new IllegalArgumentException("Stored filename cannot be empty.");
        }
        // creatorId can be null if uploads are allowed anonymously, but for quizzes, it should be present.
        // We'll enforce creatorId presence in the calling service (QuizService).

        ImageStorage newImage = ImageStorage.builder()
                .creatorId(creatorId)
                .fileName(StringUtils.cleanPath(Objects.requireNonNull(originalFile.getOriginalFilename())))
                .filePath(storedFilename) // This is the unique name like UUID.ext
                .contentType(originalFile.getContentType())
                .fileSize(originalFile.getSize())
                // createdAt and updatedAt are set by @PrePersist
                .build();
        return imageStorageRepository.save(newImage);
    }


    @Override
    @Transactional // Kept from existing, good for consistency
    public ImageStorage createImageStorage(ImageStorage imageStorage) {
        // This is the old generic method. We prefer createImageRecord for new uploads.
        // It can still be used internally if an ImageStorage object is pre-built.
        imageStorage.setImageId(null); // Ensure ID is generated by DB
        return imageStorageRepository.save(imageStorage);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<ImageStorage> getImageStorageById(UUID imageId) {
        return imageStorageRepository.findById(imageId);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<ImageStorage> getImageByFilePath(String storedFilePath) {
        // This should query by the unique 'filePath' (e.g., UUID.ext)
        return imageStorageRepository.findByFilePath(storedFilePath);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ImageStorage> getImagesByCreatorId(UUID creatorId) {
        return imageStorageRepository.findByCreatorId(creatorId);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<ImageStorage> getAllImageStorages(Pageable pageable) {
        return imageStorageRepository.findAll(pageable);
    }

    @Override
    @Transactional
    public ImageStorage updateImageStorage(UUID imageId, ImageStorage imageDetails) {
        ImageStorage existingImage = imageStorageRepository.findById(imageId)
                .orElseThrow(() -> new ResourceNotFoundException("ImageStorage", "id", imageId));

        // Update allowed fields
        if (StringUtils.hasText(imageDetails.getFileName())) { // Original filename
            existingImage.setFileName(imageDetails.getFileName());
        }
        // filePath (stored unique name) should typically not be updated directly unless it's a file move operation.
        // existingImage.setFilePath(imageDetails.getFilePath());
        if (imageDetails.getFileSize() != null) {
            existingImage.setFileSize(imageDetails.getFileSize());
        }
        if (StringUtils.hasText(imageDetails.getContentType())) {
            existingImage.setContentType(imageDetails.getContentType());
        }
        // creatorId might be updatable in some scenarios, but usually not.

        // updatedAt is handled by @PreUpdate
        return imageStorageRepository.save(existingImage);
    }

    @Override
    @Transactional
    public void deleteImageStorage(UUID imageId) {
        // In later stages, this should also delete the file from FileStorageService
        ImageStorage image = imageStorageRepository.findById(imageId)
                .orElseThrow(() -> new ResourceNotFoundException("ImageStorage", "id", imageId));
        imageStorageRepository.delete(image); // Soft delete if @SQLDelete is used, otherwise hard delete
    }

    @Override
    @Transactional // This transaction should ideally be part of a larger one in QuizService
    public long deleteImageStorageAndFile(UUID imageId) {
        ImageStorage imageRecord = imageStorageRepository.findById(imageId)
                .orElseThrow(() -> new ResourceNotFoundException("ImageStorage record not found with id: " + imageId));

        String storedFilePath = imageRecord.getFilePath();
        long fileSize = imageRecord.getFileSize() != null ? imageRecord.getFileSize() : 0L;

        try {
            if (StringUtils.hasText(storedFilePath)) {
                fileStorageService.deleteFile(storedFilePath);
                log.info("Successfully deleted physical file: {}", storedFilePath);
            } else {
                log.warn("ImageStorage record {} has no filePath, cannot delete physical file.", imageId);
            }
        } catch (MyFileNotFoundException e) {
            // File was already gone from disk, but DB record exists. Log it.
            // This is acceptable for deletion, as the goal is to remove the DB record.
            log.warn("Physical file {} for ImageStorage record {} was not found during deletion: {}", storedFilePath, imageId, e.getMessage());
        } catch (FileStorageException e) {
            // Failed to delete the physical file for some other reason.
            // This is more problematic. Depending on policy, you might:
            // 1. Re-throw the exception and prevent DB record deletion (safest for consistency).
            // 2. Log the error and proceed with DB record deletion (might leave orphaned files if transaction rolls back later).
            // For now, let's re-throw to ensure the operation is fully successful or fully fails.
            log.error("Failed to delete physical file {} for ImageStorage record {}: {}", storedFilePath, imageId, e.getMessage());
            throw e; // Re-throw to potentially roll back the transaction if this is part of a larger one
        }

        imageStorageRepository.delete(imageRecord); // Perform soft or hard delete based on entity config
        log.info("Successfully deleted ImageStorage record: {}", imageId);
        return fileSize;
    }

    @Override
    @Transactional
    public ImageStorage findOrCreateByFilePath(String filePath, UUID creatorId) {
        // This method seems to assume filePath is a public URL or an external path.
        // For our internal flow, 'filePath' argument here would ideally be the unique stored name.
        // If it's an external URL, it needs to download it first, which is beyond this stage.
        // Let's assume for now 'filePath' is the unique stored name.
        // If so, it simplifies to:
        // return imageStorageRepository.findByFilePath(filePath).orElseGet(() -> {
        //      // This part is tricky if we only have the stored path.
        //      // We'd need original filename, content type, size to create a new record.
        //      // This method might be better suited for scenarios where you're trying to reference an existing image by its URL.
        //      // For now, let's keep the existing implementation and refine if its use case becomes clearer.
        // });

        // Your existing implementation:
        if (filePath == null || filePath.trim().isEmpty()) {
            return null; // Or throw IllegalArgumentException
        }
        Optional<ImageStorage> existingImage = imageStorageRepository.findByFilePath(filePath); // Assumes filePath is the unique stored name
        if (existingImage.isPresent()) {
            return existingImage.get();
        } else {
            // This 'else' block is problematic if filePath is just a URL, as we don't have the MultipartFile.
            // For this stage, we will primarily use `createImageRecord`.
            // The existing `findOrCreateByFilePath` logic might be useful if you receive full image URLs
            // in DTOs from external sources and want to internalize them.
            // If `filePath` here IS the unique stored filename that somehow wasn't in DB:
            // This indicates an inconsistency or a different use case.
            // For now, let's keep it but note that `createImageRecord` is for new uploads.

            String originalFileNameFromFilePath = filePath.substring(filePath.lastIndexOf('/') + 1);
            String extension = StringUtils.getFilenameExtension(originalFileNameFromFilePath);
            String contentType = "image/" + (extension != null ? extension : "jpeg");

            ImageStorage newImage = ImageStorage.builder()
                    .filePath(filePath) // This is the UNIQUE stored path
                    .creatorId(creatorId)
                    .fileName(originalFileNameFromFilePath) // Best guess for original name
                    .contentType(contentType)
                    .fileSize(0L) // Placeholder, actual size not known from just URL
                    .build();
            return imageStorageRepository.save(newImage);
        }
    }

    @Override
    public String getPublicUrl(ImageStorage imageStorage) {
        if (imageStorage == null || !StringUtils.hasText(imageStorage.getFilePath())) {
            return null;
        }
        return getPublicUrl(imageStorage.getFilePath());
    }

    @Override
    public String getPublicUrl(String storedFilename) {
        if (!StringUtils.hasText(storedFilename)) {
            return null;
        }

        // Convert to lowercase for a case-insensitive check for "http://" or "https://"
        String lowerCaseStoredFilename = storedFilename.toLowerCase();

        // Check if the storedFilename is already an absolute URL
        if (lowerCaseStoredFilename.startsWith("http://") || lowerCaseStoredFilename.startsWith("https://")) {
            return storedFilename; // It's already a full URL, return it as is.
        }

        // Otherwise, assume it's a local file and construct the URL
        // Ensure no leading slashes if storedFilename is just the name intended for local path construction
        String cleanStoredFilename = storedFilename.startsWith("/") ? storedFilename.substring(1) : storedFilename;

        return ServletUriComponentsBuilder.fromCurrentContextPath()
                .path("/files/images/") // Matches FileController endpoint
                .path(cleanStoredFilename) // cleanStoredFilename should be just the filename like "uuid.jpg"
                .toUriString();
    }

    @Override
    public String getPublicUrl(UUID imageId) { // ADD THIS IMPLEMENTATION
        if (imageId == null) {
            return null;
        }
        return imageStorageRepository.findById(imageId)
                .map(this::getPublicUrl) // Calls the existing getPublicUrl(ImageStorage imageStorage)
                .orElse(null);
    }
}